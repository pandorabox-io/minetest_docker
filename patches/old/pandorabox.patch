diff --git a/.github/pull.yml b/.github/pull.yml
new file mode 100644
index 00000000..14f95a34
--- /dev/null
+++ b/.github/pull.yml
@@ -0,0 +1,8 @@
+version: "1"
+rules:
+  - base: master
+    upstream: minetest:master
+    mergeMethod: hardreset
+  - base: pandorabox
+    upstream: minetest:master
+    mergeMethod: merge
diff --git a/Dockerfile b/Dockerfile
index 37b90e48..2f1de80b 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,40 +1,62 @@
-FROM debian:stretch
+FROM ubuntu:19.10
+
+
+ENV GAME_BRANCH=5.1.0
+ENV GAME_REPO=https://github.com/minetest/minetest_game.git
+
+
+# https://github.com/minetest/minetest
+RUN apt-get update &&\
+ apt-get install -y build-essential libirrlicht-dev cmake libbz2-dev libpng-dev libjpeg-dev libsqlite3-dev libcurl4-openssl-dev \
+	zlib1g-dev libgmp-dev libjsoncpp-dev git libluajit-5.1-dev lua5.1 \
+	libjsoncpp-dev libgmp-dev postgresql-server-dev-all postgresql-client libspatialindex5 libspatialindex-dev
+
+RUN mkdir /git
+
+# prometheus stuff
+RUN cd /git && git clone https://github.com/jupp0r/prometheus-cpp -b v0.7.0 &&\
+ cd prometheus-cpp &&\
+ git submodule init &&\
+ git submodule update &&\
+ mkdir _build && cd _build &&\
+ cmake .. -DBUILD_SHARED_LIBS=ON &&\
+ make -j4 &&\
+ make install &&\
+ cp /usr/local/lib/libprometheus-cpp-*.so /lib/x86_64-linux-gnu &&\
+ cp /usr/local/lib/libprometheus-cpp-*.so /lib/x86_64-linux-gnu/
+
+# minetest
+COPY . /git/minetest
+RUN cd /git/minetest/ && rm -rf games/minetest_game && git clone --depth 1 ${GAME_REPO} games/minetest_game -b ${GAME_BRANCH} &&\
+ cmake . \
+	-DCMAKE_INSTALL_PREFIX=/usr/local\
+	-DCMAKE_BUILD_TYPE=Debug \
+	-DRUN_IN_PLACE=FALSE\
+	-DBUILD_SERVER=TRUE\
+	-DBUILD_CLIENT=FALSE\
+	-DENABLE_SPATIAL=TRUE\
+	-DENABLE_LUAJIT=TRUE\
+	-DENABLE_CURSES=TRUE\
+	-DENABLE_POSTGRESQL=TRUE\
+	-DENABLE_SYSTEM_GMP=TRUE \
+	-DENABLE_SYSTEM_JSONCPP=TRUE \
+	-DVERSION_EXTRA=docker &&\
+ make -j4 &&\
+ make install
+
+
+FROM ubuntu:19.10
 
-USER root
-RUN apt-get update -y && \
-	apt-get -y install build-essential libirrlicht-dev cmake libbz2-dev libpng-dev libjpeg-dev \
-		libsqlite3-dev libcurl4-gnutls-dev zlib1g-dev libgmp-dev libjsoncpp-dev git
-
-COPY . /usr/src/minetest
-
-RUN	mkdir -p /usr/src/minetest/cmakebuild && cd /usr/src/minetest/cmakebuild && \
-    	cmake -DCMAKE_INSTALL_PREFIX=/usr/local -DCMAKE_BUILD_TYPE=Release -DRUN_IN_PLACE=FALSE \
-		-DBUILD_SERVER=TRUE \
-		-DBUILD_CLIENT=FALSE \
-		-DENABLE_SYSTEM_JSONCPP=1 \
-		.. && \
-		make -j2 && \
-		rm -Rf ../games/minetest_game && git clone --depth 1 https://github.com/minetest/minetest_game ../games/minetest_game && \
-		rm -Rf ../games/minetest_game/.git && \
-		make install
-
-FROM debian:stretch
-
-USER root
 RUN groupadd minetest && useradd -m -g minetest -d /var/lib/minetest minetest && \
     apt-get update -y && \
-    apt-get -y install libcurl3-gnutls libjsoncpp1 liblua5.1-0 libluajit-5.1-2 libpq5 libsqlite3-0 \
-        libstdc++6 zlib1g libc6 && \
-    apt-get clean && rm -rf /var/cache/apt/archives/* && \
-    rm -rf /var/lib/apt/lists/*
+    apt-get -y install libcurl4 libjsoncpp1 liblua5.1-0 libluajit-5.1-2 libpq5 libsqlite3-0 \
+        libstdc++6 zlib1g libc6 libspatialindex5 libpq5 postgresql-client
 
 WORKDIR /var/lib/minetest
 
 COPY --from=0 /usr/local/share/minetest /usr/local/share/minetest
 COPY --from=0 /usr/local/bin/minetestserver /usr/local/bin/minetestserver
-COPY --from=0 /usr/local/share/doc/minetest/minetest.conf.example /etc/minetest/minetest.conf
-
-USER minetest
+COPY --from=0 /usr/local/lib/libprometheus-cpp-*.so /lib/x86_64-linux-gnu/
 
 EXPOSE 30000/udp
 
diff --git a/builtin/game/privileges.lua b/builtin/game/privileges.lua
index c7417d2f..4b68bfcd 100644
--- a/builtin/game/privileges.lua
+++ b/builtin/game/privileges.lua
@@ -95,6 +95,11 @@ core.register_privilege("debug", {
 	give_to_admin = true,
 })
 
+core.register_privilege("status_hide", {
+	description = "name hidden from /status",
+	give_to_singleplayer = false,
+})
+
 core.register_can_bypass_userlimit(function(name, ip)
 	local privs = core.get_player_privs(name)
 	return privs["server"] or privs["ban"] or privs["privs"] or privs["password"]
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index db8645c6..eb4bd1c0 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -233,6 +233,15 @@ if(ENABLE_SPATIAL)
 endif(ENABLE_SPATIAL)
 
 
+# prometheus monitoring
+find_package(prometheus-cpp QUIET)
+if(prometheus-cpp_FOUND)
+	set(USE_PROMETHEUS TRUE)
+	add_compile_definitions(ENABLE_PROMETHEUS TRUE)
+	message(STATUS "prometheus-cpp enabled")
+endif()
+
+
 if(NOT MSVC)
 	set(USE_GPROF FALSE CACHE BOOL "Use -pg flag for g++")
 endif()
@@ -402,6 +411,7 @@ set(common_SRCS
 	mapsector.cpp
 	metadata.cpp
 	modchannels.cpp
+	monitoring.cpp
 	nameidmapping.cpp
 	nodedef.cpp
 	nodemetadata.cpp
@@ -541,9 +551,22 @@ if(BUILD_CLIENT)
 		${PLATFORM_LIBS}
 		${CLIENT_PLATFORM_LIBS}
 	)
-	target_link_libraries(
-		${client_LIBS}
-	)
+
+	# prometheus monitoring
+	if(USE_PROMETHEUS)
+		target_link_libraries(${PROJECT_NAME} prometheus-cpp::core prometheus-cpp::pull)
+	endif()
+
+	if(APPLE)
+		target_link_libraries(
+			${client_LIBS}
+			${ICONV_LIBRARY}
+		)
+	else()
+		target_link_libraries(
+			${client_LIBS}
+		)
+	endif()
 	if(ENABLE_GLES)
 		target_link_libraries(
 			${PROJECT_NAME}
@@ -610,6 +633,12 @@ if(BUILD_SERVER)
 		${GMP_LIBRARY}
 		${PLATFORM_LIBS}
 	)
+
+	# prometheus monitoring
+	if(USE_PROMETHEUS)
+		target_link_libraries(${PROJECT_NAME}server prometheus-cpp::core prometheus-cpp::pull)
+	endif()
+
 	set_target_properties(${PROJECT_NAME}server PROPERTIES
 			COMPILE_DEFINITIONS "SERVER")
 	if (USE_GETTEXT)
diff --git a/src/database/CMakeLists.txt b/src/database/CMakeLists.txt
index e9d157c2..839c9152 100644
--- a/src/database/CMakeLists.txt
+++ b/src/database/CMakeLists.txt
@@ -4,6 +4,8 @@ set(database_SRCS
 	${CMAKE_CURRENT_SOURCE_DIR}/database-files.cpp
 	${CMAKE_CURRENT_SOURCE_DIR}/database-leveldb.cpp
 	${CMAKE_CURRENT_SOURCE_DIR}/database-postgresql.cpp
+	${CMAKE_CURRENT_SOURCE_DIR}/postgres/mapsavequeue.cpp
+	${CMAKE_CURRENT_SOURCE_DIR}/postgres/playersavequeue.cpp
 	${CMAKE_CURRENT_SOURCE_DIR}/database-redis.cpp
 	${CMAKE_CURRENT_SOURCE_DIR}/database-sqlite3.cpp
 	PARENT_SCOPE
diff --git a/src/database/database-postgresql.cpp b/src/database/database-postgresql.cpp
index d7c94ff1..d81ae7db 100644
--- a/src/database/database-postgresql.cpp
+++ b/src/database/database-postgresql.cpp
@@ -54,11 +54,14 @@ Database_PostgreSQL::Database_PostgreSQL(const std::string &connect_string) :
 			"DELETE rights on the database.\n"
 			"Don't create mt_user as a SUPERUSER!");
 	}
+
+
 }
 
 Database_PostgreSQL::~Database_PostgreSQL()
 {
-	PQfinish(m_conn);
+  PQfinish(m_conn);
+  PQfinish(m_async_conn);
 }
 
 void Database_PostgreSQL::connectToDatabase()
@@ -71,6 +74,14 @@ void Database_PostgreSQL::connectToDatabase()
 			PQerrorMessage(m_conn));
 	}
 
+	m_async_conn = PQconnectdb(m_connect_string.c_str());
+
+	if (PQstatus(m_async_conn) != CONNECTION_OK) {
+		throw DatabaseException(std::string(
+			"PostgreSQL async database error: ") +
+			PQerrorMessage(m_async_conn));
+	}
+
 	m_pgversion = PQserverVersion(m_conn);
 
 	/*
@@ -113,37 +124,16 @@ bool Database_PostgreSQL::initialized() const
 	return (PQstatus(m_conn) == CONNECTION_OK);
 }
 
-PGresult *Database_PostgreSQL::checkResults(PGresult *result, bool clear)
-{
-	ExecStatusType statusType = PQresultStatus(result);
-
-	switch (statusType) {
-	case PGRES_COMMAND_OK:
-	case PGRES_TUPLES_OK:
-		break;
-	case PGRES_FATAL_ERROR:
-	default:
-		throw DatabaseException(
-			std::string("PostgreSQL database error: ") +
-			PQresultErrorMessage(result));
-	}
-
-	if (clear)
-		PQclear(result);
-
-	return result;
-}
-
 void Database_PostgreSQL::createTableIfNotExists(const std::string &table_name,
 		const std::string &definition)
 {
 	std::string sql_check_table = "SELECT relname FROM pg_class WHERE relname='" +
 		table_name + "';";
-	PGresult *result = checkResults(PQexec(m_conn, sql_check_table.c_str()), false);
+	PGresult *result = PGUtil::checkResults(PQexec(m_conn, sql_check_table.c_str()), false);
 
 	// If table doesn't exist, create it
 	if (!PQntuples(result)) {
-		checkResults(PQexec(m_conn, definition.c_str()));
+		PGUtil::checkResults(PQexec(m_conn, definition.c_str()));
 	}
 
 	PQclear(result);
@@ -152,12 +142,12 @@ void Database_PostgreSQL::createTableIfNotExists(const std::string &table_name,
 void Database_PostgreSQL::beginSave()
 {
 	verifyDatabase();
-	checkResults(PQexec(m_conn, "BEGIN;"));
+	PGUtil::checkResults(PQexec(m_conn, "BEGIN;"));
 }
 
 void Database_PostgreSQL::endSave()
 {
-	checkResults(PQexec(m_conn, "COMMIT;"));
+	PGUtil::checkResults(PQexec(m_conn, "COMMIT;"));
 }
 
 MapDatabasePostgreSQL::MapDatabasePostgreSQL(const std::string &connect_string):
@@ -165,8 +155,23 @@ MapDatabasePostgreSQL::MapDatabasePostgreSQL(const std::string &connect_string):
 	MapDatabase()
 {
 	connectToDatabase();
+
+	save_block_count = g_monitoring->createCounter("minetest_pg_save_block_count", "Number of save block calls");
+	save_block_time = g_monitoring->createCounter("minetest_pg_save_block_time", "Time of save block calls");
+
+	load_block_count = g_monitoring->createCounter("minetest_pg_load_block_count", "Number of load block calls");
+	load_block_time = g_monitoring->createCounter("minetest_pg_load_block_time", "Time of load block calls");
+
+	save_queue = new MapSaveQueue(m_async_conn);
+	save_queue->start();
 }
 
+MapDatabasePostgreSQL::~MapDatabasePostgreSQL(){
+	save_queue->stop();
+	save_queue->wait();
+
+	delete save_queue;
+}
 
 void MapDatabasePostgreSQL::createDatabase()
 {
@@ -185,72 +190,35 @@ void MapDatabasePostgreSQL::createDatabase()
 
 void MapDatabasePostgreSQL::initStatements()
 {
-	prepareStatement("read_block",
+	PGUtil::prepareStatement(m_conn, "read_block",
 		"SELECT data FROM blocks "
 			"WHERE posX = $1::int4 AND posY = $2::int4 AND "
 			"posZ = $3::int4");
 
-	if (getPGVersion() < 90500) {
-		prepareStatement("write_block_insert",
-			"INSERT INTO blocks (posX, posY, posZ, data) SELECT "
-				"$1::int4, $2::int4, $3::int4, $4::bytea "
-				"WHERE NOT EXISTS (SELECT true FROM blocks "
-				"WHERE posX = $1::int4 AND posY = $2::int4 AND "
-				"posZ = $3::int4)");
-
-		prepareStatement("write_block_update",
-			"UPDATE blocks SET data = $4::bytea "
-				"WHERE posX = $1::int4 AND posY = $2::int4 AND "
-				"posZ = $3::int4");
-	} else {
-		prepareStatement("write_block",
-			"INSERT INTO blocks (posX, posY, posZ, data) VALUES "
-				"($1::int4, $2::int4, $3::int4, $4::bytea) "
-				"ON CONFLICT ON CONSTRAINT blocks_pkey DO "
-				"UPDATE SET data = $4::bytea");
-	}
-
-	prepareStatement("delete_block", "DELETE FROM blocks WHERE "
+	PGUtil::prepareStatement(m_conn, "delete_block", "DELETE FROM blocks WHERE "
 		"posX = $1::int4 AND posY = $2::int4 AND posZ = $3::int4");
 
-	prepareStatement("list_all_loadable_blocks",
+	PGUtil::prepareStatement(m_conn, "list_all_loadable_blocks",
 		"SELECT posX, posY, posZ FROM blocks");
 }
 
 bool MapDatabasePostgreSQL::saveBlock(const v3s16 &pos, const std::string &data)
 {
-	// Verify if we don't overflow the platform integer with the mapblock size
-	if (data.size() > INT_MAX) {
-		errorstream << "Database_PostgreSQL::saveBlock: Data truncation! "
-			<< "data.size() over 0xFFFFFFFF (== " << data.size()
-			<< ")" << std::endl;
-		return false;
-	}
+	save_block_count->increment(1);
+	ScopedTimer st(save_block_time);
 
-	verifyDatabase();
+	save_queue->enqueue(pos, data);
 
-	s32 x, y, z;
-	x = htonl(pos.X);
-	y = htonl(pos.Y);
-	z = htonl(pos.Z);
+	st.stop();
 
-	const void *args[] = { &x, &y, &z, data.c_str() };
-	const int argLen[] = {
-		sizeof(x), sizeof(y), sizeof(z), (int)data.size()
-	};
-	const int argFmt[] = { 1, 1, 1, 1 };
-
-	if (getPGVersion() < 90500) {
-		execPrepared("write_block_update", ARRLEN(args), args, argLen, argFmt);
-		execPrepared("write_block_insert", ARRLEN(args), args, argLen, argFmt);
-	} else {
-		execPrepared("write_block", ARRLEN(args), args, argLen, argFmt);
-	}
 	return true;
 }
 
 void MapDatabasePostgreSQL::loadBlock(const v3s16 &pos, std::string *block)
 {
+	load_block_count->increment(1);
+	ScopedTimer st(load_block_time);
+
 	verifyDatabase();
 
 	s32 x, y, z;
@@ -262,7 +230,7 @@ void MapDatabasePostgreSQL::loadBlock(const v3s16 &pos, std::string *block)
 	const int argLen[] = { sizeof(x), sizeof(y), sizeof(z) };
 	const int argFmt[] = { 1, 1, 1 };
 
-	PGresult *results = execPrepared("read_block", ARRLEN(args), args,
+	PGresult *results = PGUtil::execPrepared(m_conn, "read_block", ARRLEN(args), args,
 		argLen, argFmt, false);
 
 	*block = "";
@@ -271,6 +239,7 @@ void MapDatabasePostgreSQL::loadBlock(const v3s16 &pos, std::string *block)
 		*block = std::string(PQgetvalue(results, 0, 0), PQgetlength(results, 0, 0));
 
 	PQclear(results);
+	st.stop();
 }
 
 bool MapDatabasePostgreSQL::deleteBlock(const v3s16 &pos)
@@ -286,7 +255,7 @@ bool MapDatabasePostgreSQL::deleteBlock(const v3s16 &pos)
 	const int argLen[] = { sizeof(x), sizeof(y), sizeof(z) };
 	const int argFmt[] = { 1, 1, 1 };
 
-	execPrepared("delete_block", ARRLEN(args), args, argLen, argFmt);
+	PGUtil::execPrepared(m_conn, "delete_block", ARRLEN(args), args, argLen, argFmt);
 
 	return true;
 }
@@ -295,13 +264,13 @@ void MapDatabasePostgreSQL::listAllLoadableBlocks(std::vector<v3s16> &dst)
 {
 	verifyDatabase();
 
-	PGresult *results = execPrepared("list_all_loadable_blocks", 0,
+	PGresult *results = PGUtil::execPrepared(m_conn, "list_all_loadable_blocks", 0,
 		NULL, NULL, NULL, false, false);
 
 	int numrows = PQntuples(results);
 
 	for (int row = 0; row < numrows; ++row)
-		dst.push_back(pg_to_v3s16(results, 0, 0));
+		dst.push_back(PGUtil::pg_to_v3s16(results, 0, 0));
 
 	PQclear(results);
 }
@@ -314,8 +283,20 @@ PlayerDatabasePostgreSQL::PlayerDatabasePostgreSQL(const std::string &connect_st
 	PlayerDatabase()
 {
 	connectToDatabase();
+
+
+	save_player_count = g_monitoring->createCounter("minetest_pg_save_player_count", "Number of save player calls");
+	save_player_time = g_monitoring->createCounter("minetest_pg_save_player_time", "Time of save player calls");
+
+	load_player_count = g_monitoring->createCounter("minetest_pg_load_player_count", "Number of load player calls");
+	load_player_time = g_monitoring->createCounter("minetest_pg_load_player_time", "Time of load player calls");
+
+	save_queue = new PlayerSaveQueue(m_async_conn);
+	save_queue->start();
 }
 
+PlayerDatabasePostgreSQL::~PlayerDatabasePostgreSQL(){
+}
 
 void PlayerDatabasePostgreSQL::createDatabase()
 {
@@ -376,61 +357,25 @@ void PlayerDatabasePostgreSQL::createDatabase()
 
 void PlayerDatabasePostgreSQL::initStatements()
 {
-	if (getPGVersion() < 90500) {
-		prepareStatement("create_player",
-			"INSERT INTO player(name, pitch, yaw, posX, posY, posZ, hp, breath) VALUES "
-				"($1, $2, $3, $4, $5, $6, $7::int, $8::int)");
-
-		prepareStatement("update_player",
-			"UPDATE SET pitch = $2, yaw = $3, posX = $4, posY = $5, posZ = $6, hp = $7::int, "
-				"breath = $8::int, modification_date = NOW() WHERE name = $1");
-	} else {
-		prepareStatement("save_player",
-			"INSERT INTO player(name, pitch, yaw, posX, posY, posZ, hp, breath) VALUES "
-				"($1, $2, $3, $4, $5, $6, $7::int, $8::int)"
-				"ON CONFLICT ON CONSTRAINT player_pkey DO UPDATE SET pitch = $2, yaw = $3, "
-				"posX = $4, posY = $5, posZ = $6, hp = $7::int, breath = $8::int, "
-				"modification_date = NOW()");
-	}
-
-	prepareStatement("remove_player", "DELETE FROM player WHERE name = $1");
-
-	prepareStatement("load_player_list", "SELECT name FROM player");
-
-	prepareStatement("remove_player_inventories",
-		"DELETE FROM player_inventories WHERE player = $1");
-
-	prepareStatement("remove_player_inventory_items",
-		"DELETE FROM player_inventory_items WHERE player = $1");
+	PGUtil::prepareStatement(m_conn, "remove_player", "DELETE FROM player WHERE name = $1");
 
-	prepareStatement("add_player_inventory",
-		"INSERT INTO player_inventories (player, inv_id, inv_width, inv_name, inv_size) VALUES "
-			"($1, $2::int, $3::int, $4, $5::int)");
+	PGUtil::prepareStatement(m_conn, "load_player_list", "SELECT name FROM player");
 
-	prepareStatement("add_player_inventory_item",
-		"INSERT INTO player_inventory_items (player, inv_id, slot_id, item) VALUES "
-			"($1, $2::int, $3::int, $4)");
-
-	prepareStatement("load_player_inventories",
+	PGUtil::prepareStatement(m_conn, "load_player_inventories",
 		"SELECT inv_id, inv_width, inv_name, inv_size FROM player_inventories "
 			"WHERE player = $1 ORDER BY inv_id");
 
-	prepareStatement("load_player_inventory_items",
+	PGUtil::prepareStatement(m_conn, "load_player_inventory_items",
 		"SELECT slot_id, item FROM player_inventory_items WHERE "
 			"player = $1 AND inv_id = $2::int");
 
-	prepareStatement("load_player",
+	PGUtil::prepareStatement(m_conn, "load_player",
 		"SELECT pitch, yaw, posX, posY, posZ, hp, breath FROM player WHERE name = $1");
 
-	prepareStatement("remove_player_metadata",
-		"DELETE FROM player_metadata WHERE player = $1");
-
-	prepareStatement("save_player_metadata",
-		"INSERT INTO player_metadata (player, attr, value) VALUES ($1, $2, $3)");
-
-	prepareStatement("load_player_metadata",
+	PGUtil::prepareStatement(m_conn, "load_player_metadata",
 		"SELECT attr, value FROM player_metadata WHERE player = $1");
 
+
 }
 
 bool PlayerDatabasePostgreSQL::playerDataExists(const std::string &playername)
@@ -438,7 +383,7 @@ bool PlayerDatabasePostgreSQL::playerDataExists(const std::string &playername)
 	verifyDatabase();
 
 	const char *values[] = { playername.c_str() };
-	PGresult *results = execPrepared("load_player", 1, values, false);
+	PGresult *results = PGUtil::execPrepared(m_conn, "load_player", 1, values, false);
 
 	bool res = (PQntuples(results) > 0);
 	PQclear(results);
@@ -447,98 +392,31 @@ bool PlayerDatabasePostgreSQL::playerDataExists(const std::string &playername)
 
 void PlayerDatabasePostgreSQL::savePlayer(RemotePlayer *player)
 {
+
+	save_player_count->increment(1);
+	ScopedTimer st(save_player_time);
+
 	PlayerSAO* sao = player->getPlayerSAO();
 	if (!sao)
 		return;
 
-	verifyDatabase();
-
-	v3f pos = sao->getBasePosition();
-	std::string pitch = ftos(sao->getLookPitch());
-	std::string yaw = ftos(sao->getRotation().Y);
-	std::string posx = ftos(pos.X);
-	std::string posy = ftos(pos.Y);
-	std::string posz = ftos(pos.Z);
-	std::string hp = itos(sao->getHP());
-	std::string breath = itos(sao->getBreath());
-	const char *values[] = {
-		player->getName(),
-		pitch.c_str(),
-		yaw.c_str(),
-		posx.c_str(), posy.c_str(), posz.c_str(),
-		hp.c_str(),
-		breath.c_str()
-	};
-
-	const char* rmvalues[] = { player->getName() };
-	beginSave();
-
-	if (getPGVersion() < 90500) {
-		if (!playerDataExists(player->getName()))
-			execPrepared("create_player", 8, values, true, false);
-		else
-			execPrepared("update_player", 8, values, true, false);
-	}
-	else
-		execPrepared("save_player", 8, values, true, false);
-
-	// Write player inventories
-	execPrepared("remove_player_inventories", 1, rmvalues);
-	execPrepared("remove_player_inventory_items", 1, rmvalues);
-
-	std::vector<const InventoryList*> inventory_lists = sao->getInventory()->getLists();
-	for (u16 i = 0; i < inventory_lists.size(); i++) {
-		const InventoryList* list = inventory_lists[i];
-		const std::string &name = list->getName();
-		std::string width = itos(list->getWidth()),
-			inv_id = itos(i), lsize = itos(list->getSize());
-
-		const char* inv_values[] = {
-			player->getName(),
-			inv_id.c_str(),
-			width.c_str(),
-			name.c_str(),
-			lsize.c_str()
-		};
-		execPrepared("add_player_inventory", 5, inv_values);
-
-		for (u32 j = 0; j < list->getSize(); j++) {
-			std::ostringstream os;
-			list->getItem(j).serialize(os);
-			std::string itemStr = os.str(), slotId = itos(j);
-
-			const char* invitem_values[] = {
-				player->getName(),
-				inv_id.c_str(),
-				slotId.c_str(),
-				itemStr.c_str()
-			};
-			execPrepared("add_player_inventory_item", 4, invitem_values);
-		}
-	}
-
-	execPrepared("remove_player_metadata", 1, rmvalues);
-	const StringMap &attrs = sao->getMeta().getStrings();
-	for (const auto &attr : attrs) {
-		const char *meta_values[] = {
-			player->getName(),
-			attr.first.c_str(),
-			attr.second.c_str()
-		};
-		execPrepared("save_player_metadata", 3, meta_values);
-	}
-	endSave();
+	save_queue->enqueue(player);
 
 	player->onSuccessfulSave();
+	st.stop();
+
 }
 
 bool PlayerDatabasePostgreSQL::loadPlayer(RemotePlayer *player, PlayerSAO *sao)
 {
+	load_player_count->increment(1);
+	ScopedTimer st(load_player_time);
+
 	sanity_check(sao);
 	verifyDatabase();
 
 	const char *values[] = { player->getName() };
-	PGresult *results = execPrepared("load_player", 1, values, false, false);
+	PGresult *results = PGUtil::execPrepared(m_conn, "load_player", 1, values, false, false);
 
 	// Player not found, return not found
 	if (!PQntuples(results)) {
@@ -546,36 +424,36 @@ bool PlayerDatabasePostgreSQL::loadPlayer(RemotePlayer *player, PlayerSAO *sao)
 		return false;
 	}
 
-	sao->setLookPitch(pg_to_float(results, 0, 0));
-	sao->setRotation(v3f(0, pg_to_float(results, 0, 1), 0));
+	sao->setLookPitch(PGUtil::pg_to_float(results, 0, 0));
+	sao->setRotation(v3f(0, PGUtil::pg_to_float(results, 0, 1), 0));
 	sao->setBasePosition(v3f(
-		pg_to_float(results, 0, 2),
-		pg_to_float(results, 0, 3),
-		pg_to_float(results, 0, 4))
+		PGUtil::pg_to_float(results, 0, 2),
+		PGUtil::pg_to_float(results, 0, 3),
+		PGUtil::pg_to_float(results, 0, 4))
 	);
-	sao->setHPRaw((u16) pg_to_int(results, 0, 5));
-	sao->setBreath((u16) pg_to_int(results, 0, 6), false);
+	sao->setHPRaw((u16) PGUtil::pg_to_int(results, 0, 5));
+	sao->setBreath((u16) PGUtil::pg_to_int(results, 0, 6), false);
 
 	PQclear(results);
 
 	// Load inventory
-	results = execPrepared("load_player_inventories", 1, values, false, false);
+	results = PGUtil::execPrepared(m_conn, "load_player_inventories", 1, values, false, false);
 
 	int resultCount = PQntuples(results);
 
 	for (int row = 0; row < resultCount; ++row) {
 		InventoryList* invList = player->inventory.
-			addList(PQgetvalue(results, row, 2), pg_to_uint(results, row, 3));
-		invList->setWidth(pg_to_uint(results, row, 1));
+			addList(PQgetvalue(results, row, 2), PGUtil::pg_to_uint(results, row, 3));
+		invList->setWidth(PGUtil::pg_to_uint(results, row, 1));
 
-		u32 invId = pg_to_uint(results, row, 0);
+		u32 invId = PGUtil::pg_to_uint(results, row, 0);
 		std::string invIdStr = itos(invId);
 
 		const char* values2[] = {
 			player->getName(),
 			invIdStr.c_str()
 		};
-		PGresult *results2 = execPrepared("load_player_inventory_items", 2,
+		PGresult *results2 = PGUtil::execPrepared(m_conn, "load_player_inventory_items", 2,
 			values2, false, false);
 
 		int resultCount2 = PQntuples(results2);
@@ -584,7 +462,7 @@ bool PlayerDatabasePostgreSQL::loadPlayer(RemotePlayer *player, PlayerSAO *sao)
 			if (itemStr.length() > 0) {
 				ItemStack stack;
 				stack.deSerialize(itemStr);
-				invList->changeItem(pg_to_uint(results2, row2, 0), stack);
+				invList->changeItem(PGUtil::pg_to_uint(results2, row2, 0), stack);
 			}
 		}
 		PQclear(results2);
@@ -592,7 +470,7 @@ bool PlayerDatabasePostgreSQL::loadPlayer(RemotePlayer *player, PlayerSAO *sao)
 
 	PQclear(results);
 
-	results = execPrepared("load_player_metadata", 1, values, false);
+	results = PGUtil::execPrepared(m_conn, "load_player_metadata", 1, values, false);
 
 	int numrows = PQntuples(results);
 	for (int row = 0; row < numrows; row++) {
@@ -601,6 +479,7 @@ bool PlayerDatabasePostgreSQL::loadPlayer(RemotePlayer *player, PlayerSAO *sao)
 	sao->getMeta().setModified(false);
 
 	PQclear(results);
+	st.stop();
 
 	return true;
 }
@@ -613,7 +492,7 @@ bool PlayerDatabasePostgreSQL::removePlayer(const std::string &name)
 	verifyDatabase();
 
 	const char *values[] = { name.c_str() };
-	execPrepared("remove_player", 1, values);
+	PGUtil::execPrepared(m_conn, "remove_player", 1, values);
 
 	return true;
 }
@@ -622,7 +501,7 @@ void PlayerDatabasePostgreSQL::listPlayers(std::vector<std::string> &res)
 {
 	verifyDatabase();
 
-	PGresult *results = execPrepared("load_player_list", 0, NULL, false);
+	PGresult *results = PGUtil::execPrepared(m_conn, "load_player_list", 0, NULL, false);
 
 	int numrows = PQntuples(results);
 	for (int row = 0; row < numrows; row++)
diff --git a/src/database/database-postgresql.h b/src/database/database-postgresql.h
index db0b505c..dec6c8a6 100644
--- a/src/database/database-postgresql.h
+++ b/src/database/database-postgresql.h
@@ -23,6 +23,10 @@ with this program; if not, write to the Free Software Foundation, Inc.,
 #include <libpq-fe.h>
 #include "database.h"
 #include "util/basic_macros.h"
+#include "monitoring.h"
+#include "postgres/mapsavequeue.h"
+#include "postgres/playersavequeue.h"
+#include "postgres/pgutil.h"
 
 class Settings;
 
@@ -39,47 +43,6 @@ class Database_PostgreSQL: public Database
 
 
 protected:
-	// Conversion helpers
-	inline int pg_to_int(PGresult *res, int row, int col)
-	{
-		return atoi(PQgetvalue(res, row, col));
-	}
-
-	inline u32 pg_to_uint(PGresult *res, int row, int col)
-	{
-		return (u32) atoi(PQgetvalue(res, row, col));
-	}
-
-	inline float pg_to_float(PGresult *res, int row, int col)
-	{
-		return (float) atof(PQgetvalue(res, row, col));
-	}
-
-	inline v3s16 pg_to_v3s16(PGresult *res, int row, int col)
-	{
-		return v3s16(
-			pg_to_int(res, row, col),
-			pg_to_int(res, row, col + 1),
-			pg_to_int(res, row, col + 2)
-		);
-	}
-
-	inline PGresult *execPrepared(const char *stmtName, const int paramsNumber,
-		const void **params,
-		const int *paramsLengths = NULL, const int *paramsFormats = NULL,
-		bool clear = true, bool nobinary = true)
-	{
-		return checkResults(PQexecPrepared(m_conn, stmtName, paramsNumber,
-			(const char* const*) params, paramsLengths, paramsFormats,
-			nobinary ? 1 : 0), clear);
-	}
-
-	inline PGresult *execPrepared(const char *stmtName, const int paramsNumber,
-		const char **params, bool clear = true, bool nobinary = true)
-	{
-		return execPrepared(stmtName, paramsNumber,
-			(const void **)params, NULL, NULL, clear, nobinary);
-	}
 
 	void createTableIfNotExists(const std::string &table_name, const std::string &definition);
 	void verifyDatabase();
@@ -88,59 +51,76 @@ class Database_PostgreSQL: public Database
 	void connectToDatabase();
 	virtual void createDatabase() = 0;
 	virtual void initStatements() = 0;
-	inline void prepareStatement(const std::string &name, const std::string &sql)
-	{
-		checkResults(PQprepare(m_conn, name.c_str(), sql.c_str(), 0, NULL));
-	}
 
 	const int getPGVersion() const { return m_pgversion; }
+
+	PGconn *m_async_conn = nullptr;
+	PGconn *m_conn = nullptr;
+
 private:
 	// Database connectivity checks
 	void ping();
 
-	// Database usage
-	PGresult *checkResults(PGresult *res, bool clear = true);
-
 	// Attributes
 	std::string m_connect_string;
-	PGconn *m_conn = nullptr;
 	int m_pgversion = 0;
+
 };
 
 class MapDatabasePostgreSQL : private Database_PostgreSQL, public MapDatabase
 {
 public:
 	MapDatabasePostgreSQL(const std::string &connect_string);
-	virtual ~MapDatabasePostgreSQL() = default;
+	~MapDatabasePostgreSQL();
 
 	bool saveBlock(const v3s16 &pos, const std::string &data);
 	void loadBlock(const v3s16 &pos, std::string *block);
 	bool deleteBlock(const v3s16 &pos);
 	void listAllLoadableBlocks(std::vector<v3s16> &dst);
 
-	void beginSave() { Database_PostgreSQL::beginSave(); }
-	void endSave() { Database_PostgreSQL::endSave(); }
+	// nothing to see here, move along...
+	void beginSave() {}
+	void endSave() {}
 
 protected:
 	virtual void createDatabase();
 	virtual void initStatements();
+
+private:
+	Counter* save_block_count;
+	Counter* save_block_time;
+	Counter* load_block_count;
+	Counter* load_block_time;
+
+	MapSaveQueue *save_queue;
 };
 
 class PlayerDatabasePostgreSQL : private Database_PostgreSQL, public PlayerDatabase
 {
 public:
 	PlayerDatabasePostgreSQL(const std::string &connect_string);
-	virtual ~PlayerDatabasePostgreSQL() = default;
+	~PlayerDatabasePostgreSQL();
 
 	void savePlayer(RemotePlayer *player);
 	bool loadPlayer(RemotePlayer *player, PlayerSAO *sao);
 	bool removePlayer(const std::string &name);
 	void listPlayers(std::vector<std::string> &res);
 
+	// nothing to see here, move along...
+	void beginSave() {}
+	void endSave() {}
+
 protected:
 	virtual void createDatabase();
 	virtual void initStatements();
 
 private:
 	bool playerDataExists(const std::string &playername);
+
+	Counter* save_player_count;
+	Counter* save_player_time;
+	Counter* load_player_count;
+	Counter* load_player_time;
+
+	PlayerSaveQueue* save_queue;
 };
diff --git a/src/database/postgres/mapsavequeue.cpp b/src/database/postgres/mapsavequeue.cpp
new file mode 100644
index 00000000..0cbef450
--- /dev/null
+++ b/src/database/postgres/mapsavequeue.cpp
@@ -0,0 +1,153 @@
+
+#include "config.h"
+
+#ifdef USE_POSTGRESQL
+
+#include "mapsavequeue.h"
+
+#include "log.h"
+#include "threading/mutex_auto_lock.h"
+#include "exceptions.h"
+
+#include <thread>
+#include <chrono>
+#include <list>
+#include "pgutil.h"
+
+MapSaveQueue::MapSaveQueue(PGconn *m_conn) :
+	Thread("map_save_queue"),
+	m_conn(m_conn) {
+
+	m_pgversion = PQserverVersion(m_conn);
+
+	if (m_pgversion < 90500) {
+		PGUtil::prepareStatement(m_conn, "write_block_insert",
+			"INSERT INTO blocks (posX, posY, posZ, data) SELECT "
+				"$1::int4, $2::int4, $3::int4, $4::bytea "
+				"WHERE NOT EXISTS (SELECT true FROM blocks "
+				"WHERE posX = $1::int4 AND posY = $2::int4 AND "
+				"posZ = $3::int4)");
+
+		PGUtil::prepareStatement(m_conn, "write_block_update",
+			"UPDATE blocks SET data = $4::bytea "
+				"WHERE posX = $1::int4 AND posY = $2::int4 AND "
+				"posZ = $3::int4");
+	} else {
+		PGUtil::prepareStatement(m_conn, "write_block",
+			"INSERT INTO blocks (posX, posY, posZ, data) VALUES "
+				"($1::int4, $2::int4, $3::int4, $4::bytea) "
+				"ON CONFLICT ON CONSTRAINT blocks_pkey DO "
+				"UPDATE SET data = $4::bytea");
+	}
+
+}
+
+MapSaveQueue::~MapSaveQueue(){}
+
+void *MapSaveQueue::run(){
+	std::vector<QueuedItem*> save_items;
+
+	while (!stopRequested()){
+		std::this_thread::sleep_for(std::chrono::milliseconds(1000));
+
+		// move items over here
+		MutexAutoLock lock(m_mutex);
+		if (!queue.empty()){
+			save_items.swap(queue);
+		}
+
+		this->save(&save_items);
+		save_items.clear();
+	}
+
+
+	if (!queue.empty()){
+		//flush at exit
+		MutexAutoLock lock(m_mutex);
+		this->save(&queue);
+	}
+
+	return nullptr;
+}
+
+void MapSaveQueue::saveBlock(QueuedItem *item){
+	// Verify if we don't overflow the platform integer with the mapblock size
+	if (item->data.size() > INT_MAX) {
+		errorstream << "Database_PostgreSQL::saveBlock: Data truncation! "
+		<< "data.size() over 0xFFFFFFFF (== " << item->data.size()
+		<< ")" << std::endl;
+		throw DatabaseException(std::string(
+			"PostgreSQL database error: data truncation @ " +
+			std::to_string(item->pos.X) + "/" +
+			std::to_string(item->pos.Y) + "/" +
+			std::to_string(item->pos.Z)
+			)
+		);
+	}
+
+	if (PQstatus(m_conn) != CONNECTION_OK){
+		throw DatabaseException(std::string(
+			"PostgreSQL database error: ") +
+			PQerrorMessage(m_conn)
+		);
+	}
+
+	s32 x, y, z;
+	x = htonl(item->pos.X);
+	y = htonl(item->pos.Y);
+	z = htonl(item->pos.Z);
+
+	const void *args[] = { &x, &y, &z, item->data.c_str() };
+	const int argLen[] = {
+		sizeof(x), sizeof(y), sizeof(z), (int)(item->data.size())
+	};
+	const int argFmt[] = { 1, 1, 1, 1 };
+
+	if (m_pgversion < 90500) {
+		PGUtil::execPrepared(m_conn, "write_block_update", ARRLEN(args), args, argLen, argFmt);
+		PGUtil::execPrepared(m_conn, "write_block_insert", ARRLEN(args), args, argLen, argFmt);
+	} else {
+		PGUtil::execPrepared(m_conn, "write_block", ARRLEN(args), args, argLen, argFmt);
+	}
+
+}
+
+void MapSaveQueue::save(std::vector<QueuedItem*> *items){
+
+	try {
+		PGUtil::checkResults(PQexec(m_conn, "BEGIN;"));
+
+		for (QueuedItem* item: *items){
+			saveBlock(item);
+			delete item;
+		}
+
+		PGUtil::checkResults(PQexec(m_conn, "COMMIT;"));
+
+	} catch (std::exception &e) {
+		MutexAutoLock lock(m_exception_mutex);
+		m_async_exception = std::current_exception();
+		this->stop();
+
+	}
+}
+
+
+void MapSaveQueue::enqueue(const v3s16 &pos, const std::string &data){
+	{
+		MutexAutoLock lock(m_exception_mutex);
+		if (m_async_exception) {
+			std::rethrow_exception(m_async_exception);
+		}
+	}
+
+	MutexAutoLock lock(m_mutex);
+
+	QueuedItem *item = new QueuedItem();
+	item->pos = pos;
+	item->data = data;
+
+	queue.push_back(item);
+}
+
+#endif //USE_POSTGRESQL
\ No newline at end of file
diff --git a/src/database/postgres/mapsavequeue.h b/src/database/postgres/mapsavequeue.h
new file mode 100644
index 00000000..aadb8e60
--- /dev/null
+++ b/src/database/postgres/mapsavequeue.h
@@ -0,0 +1,67 @@
+/*
+Minetest
+Copyright (C) 2019 BuckarooBanzai/naturefreshmilk, Thomas Rudin <thomas@rudin.io>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#pragma once
+
+#include <string>
+#include "database/database.h"
+#include "threading/thread.h"
+#include "irr_v3d.h"
+#include <libpq-fe.h>
+
+// for htonl()
+#ifdef _WIN32
+        // Without this some of the network functions are not found on mingw
+        #ifndef _WIN32_WINNT
+                #define _WIN32_WINNT 0x0501
+        #endif
+        #include <windows.h>
+        #include <winsock2.h>
+#else
+	#include <netinet/in.h>
+#endif
+
+
+struct QueuedItem {
+	v3s16 pos;
+	std::string data;
+};
+
+class MapSaveQueue : public Thread {
+public:
+	MapSaveQueue(PGconn *m_conn);
+	~MapSaveQueue();
+	void enqueue(const v3s16 &pos, const std::string &data);
+
+protected:
+	void *run();
+
+private:
+	PGconn *m_conn = nullptr;
+	std::exception_ptr m_async_exception;
+	int m_pgversion;
+	void save(std::vector<QueuedItem*> *items);
+	void saveBlock(QueuedItem *item);
+
+	std::mutex m_mutex;
+	std::mutex m_exception_mutex;
+
+	std::vector<QueuedItem*> queue;
+
+};
diff --git a/src/database/postgres/pgutil.h b/src/database/postgres/pgutil.h
new file mode 100644
index 00000000..8010e873
--- /dev/null
+++ b/src/database/postgres/pgutil.h
@@ -0,0 +1,94 @@
+/*
+Minetest
+Copyright (C) 2019 BuckarooBanzai/naturefreshmilk, Thomas Rudin <thomas@rudin.io>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+#pragma once
+
+#include <libpq-fe.h>
+#include "irr_v3d.h"
+#include "exceptions.h"
+
+namespace PGUtil {
+
+	inline PGresult *checkResults(PGresult *result, bool clear = true)
+	{
+		ExecStatusType statusType = PQresultStatus(result);
+
+		switch (statusType) {
+		case PGRES_COMMAND_OK:
+		case PGRES_TUPLES_OK:
+			break;
+		case PGRES_FATAL_ERROR:
+		default:
+			throw DatabaseException(
+				std::string("PostgreSQL database error: ") +
+				PQresultErrorMessage(result));
+		}
+
+		if (clear)
+			PQclear(result);
+
+		return result;
+	}
+
+	inline void prepareStatement(PGconn *m_conn, const std::string &name, const std::string &sql)
+	{
+		checkResults(PQprepare(m_conn, name.c_str(), sql.c_str(), 0, NULL));
+	}
+
+	inline PGresult *execPrepared(PGconn *m_conn, const char *stmtName, const int paramsNumber,
+		const void **params,
+		const int *paramsLengths = NULL, const int *paramsFormats = NULL,
+		bool clear = true, bool nobinary = true) {
+
+		return checkResults(PQexecPrepared(m_conn, stmtName, paramsNumber,
+			(const char* const*) params, paramsLengths, paramsFormats,
+			nobinary ? 1 : 0), clear);
+	}
+
+	inline PGresult *execPrepared(PGconn *m_conn, const char *stmtName, const int paramsNumber,
+		const char **params, bool clear = true, bool nobinary = true) {
+		return execPrepared(m_conn, stmtName, paramsNumber,
+			(const void **)params, NULL, NULL, clear, nobinary);
+	}
+
+	// Conversion helpers
+	inline int pg_to_int(PGresult *res, int row, int col)
+	{
+		return atoi(PQgetvalue(res, row, col));
+	}
+
+	inline u32 pg_to_uint(PGresult *res, int row, int col)
+	{
+		return (u32) atoi(PQgetvalue(res, row, col));
+	}
+
+	inline float pg_to_float(PGresult *res, int row, int col)
+	{
+		return (float) atof(PQgetvalue(res, row, col));
+	}
+
+	inline v3s16 pg_to_v3s16(PGresult *res, int row, int col)
+	{
+		return v3s16(
+			pg_to_int(res, row, col),
+			pg_to_int(res, row, col + 1),
+			pg_to_int(res, row, col + 2)
+		);
+	}
+
+}
\ No newline at end of file
diff --git a/src/database/postgres/playersavequeue.cpp b/src/database/postgres/playersavequeue.cpp
new file mode 100644
index 00000000..b14349f3
--- /dev/null
+++ b/src/database/postgres/playersavequeue.cpp
@@ -0,0 +1,317 @@
+
+#include "config.h"
+
+#if USE_POSTGRESQL
+
+#include "playersavequeue.h"
+
+#include "log.h"
+#include "threading/mutex_auto_lock.h"
+#include "exceptions.h"
+#include "pgutil.h"
+#include "content_sao.h"
+
+#include <thread>
+#include <chrono>
+#include <list>
+
+
+/*
+Serialized player data
+*/
+
+SerializedPlayer::SerializedPlayer(RemotePlayer *player){
+	PlayerSAO* sao = player->getPlayerSAO();
+	v3f pos = sao->getBasePosition();
+
+	name = player->getName();
+	pitch = ftos(sao->getLookPitch());
+	yaw = ftos(sao->getRotation().Y);
+	posx = ftos(pos.X);
+	posy = ftos(pos.Y);
+	posz = ftos(pos.Z);
+	hp = itos(sao->getHP());
+	breath = itos(sao->getBreath());
+}
+
+void SerializedPlayer::persist(PGconn *m_conn, int pgversion){
+	const char *values[] = {
+		name.c_str(),
+		pitch.c_str(),
+		yaw.c_str(),
+		posx.c_str(), posy.c_str(), posz.c_str(),
+		hp.c_str(),
+		breath.c_str()
+	};
+
+	if (pgversion < 90500) {
+
+		const char *exists_values[] = { name.c_str() };
+		PGresult *exists_results = PGUtil::execPrepared(m_conn, "load_player", 1, exists_values, false);
+
+		bool player_exists = (PQntuples(exists_results) > 0);
+		PQclear(exists_results);
+
+		if (!player_exists)
+			PGUtil::execPrepared(m_conn, "create_player", 8, values, true, false);
+		else
+			PGUtil::execPrepared(m_conn, "update_player", 8, values, true, false);
+	} else {
+		PGUtil::execPrepared(m_conn, "save_player", 8, values, true, false);
+	}
+
+}
+
+std::string SerializedPlayer::getName(){
+	return name;
+}
+
+/*
+Serialized inventory data
+*/
+
+SerializedInventory::SerializedInventory(std::string player, std::string inv_id, const InventoryList* list){
+	this->player = player;
+	this->inv_id = inv_id;
+
+	name = list->getName();
+	width = itos(list->getWidth());
+	lsize = itos(list->getSize());
+}
+
+void SerializedInventory::persist(PGconn *m_conn){
+	const char* inv_values[] = {
+		player.c_str(),
+		inv_id.c_str(),
+		width.c_str(),
+		name.c_str(),
+		lsize.c_str()
+	};
+
+	PGUtil::execPrepared(m_conn, "add_player_inventory", 5, inv_values);
+}
+
+/*
+Serialized inventory item data
+*/
+
+SerializedInventoryItem::SerializedInventoryItem(std::string player, std::string inv_id, std::string slotId, std::string itemStr):
+	player(player), inv_id(inv_id), slotId(slotId), itemStr(itemStr)
+{}
+
+void SerializedInventoryItem::persist(PGconn *m_conn){
+	const char* invitem_values[] = {
+		player.c_str(),
+		inv_id.c_str(),
+		slotId.c_str(),
+		itemStr.c_str()
+	};
+	PGUtil::execPrepared(m_conn, "add_player_inventory_item", 4, invitem_values);
+}
+
+/*
+Serializes player metadata
+*/
+
+SerializedPlayerMetadata::SerializedPlayerMetadata(std::string player, std::string attr, std::string value):
+	player(player), attr(attr), value(value)
+{}
+
+void SerializedPlayerMetadata::persist(PGconn *m_conn){
+	const char *meta_values[] = {
+		player.c_str(),
+		attr.c_str(),
+		value.c_str()
+	};
+	PGUtil::execPrepared(m_conn, "save_player_metadata", 3, meta_values);
+}
+
+/*
+Save queue
+*/
+
+PlayerSaveQueue::PlayerSaveQueue(PGconn *m_conn) :
+	Thread("player_save_queue"),
+	m_conn(m_conn) {
+
+	m_pgversion = PQserverVersion(m_conn);
+
+	if (m_pgversion < 90500) {
+		PGUtil::prepareStatement(m_conn, "create_player",
+			"INSERT INTO player(name, pitch, yaw, posX, posY, posZ, hp, breath) VALUES "
+				"($1, $2, $3, $4, $5, $6, $7::int, $8::int)");
+
+		PGUtil::prepareStatement(m_conn, "update_player",
+			"UPDATE SET pitch = $2, yaw = $3, posX = $4, posY = $5, posZ = $6, hp = $7::int, "
+				"breath = $8::int, modification_date = NOW() WHERE name = $1");
+	} else {
+		PGUtil::prepareStatement(m_conn, "save_player",
+			"INSERT INTO player(name, pitch, yaw, posX, posY, posZ, hp, breath) VALUES "
+				"($1, $2, $3, $4, $5, $6, $7::int, $8::int)"
+				"ON CONFLICT ON CONSTRAINT player_pkey DO UPDATE SET pitch = $2, yaw = $3, "
+				"posX = $4, posY = $5, posZ = $6, hp = $7::int, breath = $8::int, "
+				"modification_date = NOW()");
+	}
+
+	PGUtil::prepareStatement(m_conn, "remove_player_inventories",
+		"DELETE FROM player_inventories WHERE player = $1");
+
+	PGUtil::prepareStatement(m_conn, "remove_player_inventory_items",
+		"DELETE FROM player_inventory_items WHERE player = $1");
+
+	PGUtil::prepareStatement(m_conn, "add_player_inventory",
+		"INSERT INTO player_inventories (player, inv_id, inv_width, inv_name, inv_size) VALUES "
+			"($1, $2::int, $3::int, $4, $5::int)");
+
+	PGUtil::prepareStatement(m_conn, "add_player_inventory_item",
+		"INSERT INTO player_inventory_items (player, inv_id, slot_id, item) VALUES "
+			"($1, $2::int, $3::int, $4)");
+
+	PGUtil::prepareStatement(m_conn, "remove_player_metadata",
+		"DELETE FROM player_metadata WHERE player = $1");
+
+	PGUtil::prepareStatement(m_conn, "save_player_metadata",
+		"INSERT INTO player_metadata (player, attr, value) VALUES ($1, $2, $3)");
+
+}
+
+PlayerSaveQueue::~PlayerSaveQueue(){
+}
+
+
+void PlayerSaveQueue::enqueue(RemotePlayer *player){
+	{
+		MutexAutoLock lock(m_exception_mutex);
+		if (m_async_exception) {
+			std::rethrow_exception(m_async_exception);
+		}
+	}
+
+	MutexAutoLock lock(m_mutex);
+
+	QueuedPlayerData *queued_data = new QueuedPlayerData;
+	queued_data->serialized_player = new SerializedPlayer(player);
+
+	std::string playername = player->getName();
+	PlayerSAO* sao = player->getPlayerSAO();
+
+	std::vector<const InventoryList*> inventory_lists = sao->getInventory()->getLists();
+	for (u16 i = 0; i < inventory_lists.size(); i++) {
+		const InventoryList* list = inventory_lists[i];
+		std::string inv_id = itos(i);
+
+		SerializedInventory* serialized_inv = new SerializedInventory(playername, inv_id, list);
+		queued_data->inventories.push_back(serialized_inv);
+
+
+		for (u32 j = 0; j < list->getSize(); j++) {
+			std::ostringstream os;
+			list->getItem(j).serialize(os);
+			std::string itemStr = os.str();
+			std::string slotId = itos(j);
+
+			SerializedInventoryItem *invItem = new SerializedInventoryItem(
+				playername,
+				inv_id,
+				slotId,
+				itemStr
+			);
+
+			queued_data->inventory_items.push_back(invItem);
+		}
+	}
+
+	const StringMap &attrs = sao->getMeta().getStrings();
+	for (const auto &attr : attrs) {
+
+		SerializedPlayerMetadata *metadata = new SerializedPlayerMetadata(
+			playername,
+			attr.first,
+			attr.second
+		);
+
+		queued_data->metadata.push_back(metadata);
+	}
+
+	queue.push_back(queued_data);
+}
+
+
+void *PlayerSaveQueue::run(){
+	std::vector<QueuedPlayerData*> save_items;
+
+	while (!stopRequested()){
+		std::this_thread::sleep_for(std::chrono::milliseconds(1000));
+
+		{
+			// move items over here
+			MutexAutoLock lock(m_mutex);
+			if (!queue.empty()){
+				save_items.swap(queue);
+			}
+		}
+
+		this->save(&save_items);
+		save_items.clear();
+	}
+
+
+	if (!queue.empty()){
+		//flush at exit
+		MutexAutoLock lock(m_mutex);
+		this->save(&queue);
+	}
+
+	return nullptr;
+}
+
+void PlayerSaveQueue::save(std::vector<QueuedPlayerData*> *queue){
+	try {
+
+		for (QueuedPlayerData* item: *queue){
+			PGUtil::checkResults(PQexec(m_conn, "BEGIN;"));
+			savePlayer(item);
+			PGUtil::checkResults(PQexec(m_conn, "COMMIT;"));
+			delete item;
+		}
+
+
+	} catch (std::exception &e) {
+		MutexAutoLock lock(m_exception_mutex);
+		m_async_exception = std::current_exception();
+		this->stop();
+
+	}
+}
+
+void PlayerSaveQueue::savePlayer(QueuedPlayerData *item){
+
+	std::string playername = item->serialized_player->getName();
+	const char* rmvalues[] = { playername.c_str() };
+
+	item->serialized_player->persist(m_conn, m_pgversion);
+
+	// Write player inventories
+	PGUtil::execPrepared(m_conn, "remove_player_inventories", 1, rmvalues);
+	PGUtil::execPrepared(m_conn, "remove_player_inventory_items", 1, rmvalues);
+	PGUtil::execPrepared(m_conn, "remove_player_metadata", 1, rmvalues);
+
+	for (SerializedInventory *inv: item->inventories){
+		inv->persist(m_conn);
+		delete inv;
+	}
+
+	for (SerializedInventoryItem *invItem: item->inventory_items){
+		invItem->persist(m_conn);
+		delete invItem;
+	}
+
+	for (SerializedPlayerMetadata *metadata: item->metadata){
+		metadata->persist(m_conn);
+		delete metadata;
+	}
+
+	delete item->serialized_player;
+}
+
+#endif //USE_POSTGRESQL
\ No newline at end of file
diff --git a/src/database/postgres/playersavequeue.h b/src/database/postgres/playersavequeue.h
new file mode 100644
index 00000000..b60ed2c1
--- /dev/null
+++ b/src/database/postgres/playersavequeue.h
@@ -0,0 +1,109 @@
+/*
+Minetest
+Copyright (C) 2019 BuckarooBanzai/naturefreshmilk, Thomas Rudin <thomas@rudin.io>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#pragma once
+
+#include <string>
+#include "database/database.h"
+#include "threading/thread.h"
+#include <libpq-fe.h>
+#include "remoteplayer.h"
+
+class SerializedPlayer {
+public:
+	SerializedPlayer(RemotePlayer *player);
+	void persist(PGconn *m_conn, int pgversion);
+	std::string getName();
+private:
+	std::string name;
+	std::string pitch;
+	std::string yaw;
+	std::string posx;
+	std::string posy;
+	std::string posz;
+	std::string hp;
+	std::string breath;
+};
+
+class SerializedInventory {
+public:
+	SerializedInventory(std::string player, std::string inv_id, const InventoryList* list);
+	void persist(PGconn *m_conn);
+private:
+	std::string player;
+	std::string inv_id;
+	std::string width;
+	std::string name;
+	std::string lsize;
+};
+
+class SerializedInventoryItem {
+public:
+	SerializedInventoryItem(std::string player, std::string inv_id, std::string slotId, std::string itemStr);
+	void persist(PGconn *m_conn);
+private:
+	std::string player;
+	std::string inv_id;
+	std::string slotId;
+	std::string itemStr;
+};
+
+class SerializedPlayerMetadata {
+public:
+	SerializedPlayerMetadata(std::string player, std::string attr, std::string value);
+	void persist(PGconn *m_conn);
+private:
+	std::string player;
+	std::string attr;
+	std::string value;
+	
+};
+
+struct QueuedPlayerData {
+	SerializedPlayer *serialized_player;
+	std::vector<SerializedInventory*> inventories;
+	std::vector<SerializedInventoryItem*> inventory_items;
+	std::vector<SerializedPlayerMetadata*> metadata;
+};
+
+
+class PlayerSaveQueue : public Thread {
+public:
+	PlayerSaveQueue(PGconn *m_conn);
+	~PlayerSaveQueue();
+	void enqueue(RemotePlayer *player);
+
+protected:
+	void *run();
+
+private:
+	std::exception_ptr m_async_exception;
+
+	int m_pgversion;
+
+	void save(std::vector<QueuedPlayerData*> *queue);
+	void savePlayer(QueuedPlayerData *playerdata);
+
+	PGconn *m_conn = nullptr;
+
+	std::mutex m_mutex;
+	std::mutex m_exception_mutex;
+
+	std::vector<QueuedPlayerData*> queue;
+};
diff --git a/src/defaultsettings.cpp b/src/defaultsettings.cpp
index 754ce354..cdec508a 100644
--- a/src/defaultsettings.cpp
+++ b/src/defaultsettings.cpp
@@ -355,6 +355,13 @@ void set_default_settings(Settings *settings)
 	settings->setDefault("disallow_empty_password", "false");
 	settings->setDefault("disable_anticheat", "false");
 	settings->setDefault("enable_rollback_recording", "false");
+
+#if ENABLE_PROMETHEUS
+	//Monitoring
+	settings->setDefault("prometheus_enable", "true");
+	settings->setDefault("prometheus_bind_address", "127.0.0.1:8080");
+#endif
+
 #ifdef NDEBUG
 	settings->setDefault("deprecated_lua_api_handling", "legacy");
 #else
diff --git a/src/main.cpp b/src/main.cpp
index 1993f7c2..28203eb9 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -52,6 +52,10 @@ with this program; if not, write to the Free Software Foundation, Inc.,
 	#include "gui/touchscreengui.h"
 #endif
 
+#if ENABLE_PROMETHEUS
+	#include "monitoring.h"
+#endif
+
 #if !defined(SERVER) && \
 	(IRRLICHT_VERSION_MAJOR == 1) && \
 	(IRRLICHT_VERSION_MINOR == 8) && \
@@ -858,6 +862,15 @@ static bool run_dedicated_server(const GameParams &game_params, const Settings &
 	if (cmd_args.exists("migrate-auth"))
 		return ServerEnvironment::migrateAuthDatabase(game_params, cmd_args);
 
+
+#if ENABLE_PROMETHEUS
+	if (g_settings->getBool("prometheus_enable")) {
+		infostream << "Exposing prometheus metrics on "
+							 << g_settings->get("prometheus_bind_address") << std::endl;
+		g_monitoring->start();
+	}
+#endif
+
 	if (cmd_args.exists("terminal")) {
 #if USE_CURSES
 		bool name_ok = true;
diff --git a/src/map.cpp b/src/map.cpp
index f1911d1a..3d8b13ad 100644
--- a/src/map.cpp
+++ b/src/map.cpp
@@ -67,6 +67,15 @@ Map::Map(std::ostream &dout, IGameDef *gamedef):
 	m_gamedef(gamedef),
 	m_nodedef(gamedef->ndef())
 {
+	m_map_timer_update_calls_metric = g_monitoring->createCounter(
+		"minetest_map_timer_update_calls",
+		"count of map timer updates"
+	);
+	m_map_timer_update_time_metric = g_monitoring->createCounter(
+		"minetest_map_timer_update_time",
+		"time of map timer updates"
+	);
+
 }
 
 Map::~Map()
@@ -325,6 +334,9 @@ struct TimeOrderedMapBlock {
 void Map::timerUpdate(float dtime, float unload_timeout, u32 max_loaded_blocks,
 		std::vector<v3s16> *unloaded_blocks)
 {
+	m_map_timer_update_calls_metric->increment(1);
+	ScopedTimer st(m_map_timer_update_time_metric);
+
 	bool save_before_unloading = (mapType() == MAPTYPE_SERVER);
 
 	// Profile modified reasons
@@ -451,6 +463,9 @@ void Map::timerUpdate(float dtime, float unload_timeout, u32 max_loaded_blocks,
 			modprofiler.print(infostream);
 		}
 	}
+
+	st.stop();
+
 }
 
 void Map::unloadUnreferencedBlocks(std::vector<v3s16> *unloaded_blocks)
@@ -1192,6 +1207,17 @@ ServerMap::ServerMap(const std::string &savedir, IGameDef *gamedef,
 	settings_mgr(g_settings, savedir + DIR_DELIM + "map_meta.txt"),
 	m_emerge(emerge)
 {
+
+
+	this->m_map_save_calls_metric = g_monitoring->createCounter(
+		"minetest_map_save_calls",
+		"count of map timer save calls"
+	);
+	this->m_map_save_time_metric = g_monitoring->createCounter(
+		"minetest_map_save_time",
+		"time of map saves"
+	);
+
 	verbosestream<<FUNCTION_NAME<<std::endl;
 
 	// Tell the EmergeManager about our MapSettingsManager
@@ -1773,6 +1799,9 @@ void ServerMap::createDirs(const std::string &path)
 
 void ServerMap::save(ModifiedState save_level)
 {
+	m_map_save_calls_metric->increment(1);
+	ScopedTimer st(m_map_save_time_metric);
+
 	if (!m_map_saving_enabled) {
 		warningstream<<"Not saving map, saving disabled."<<std::endl;
 		return;
@@ -1836,6 +1865,9 @@ void ServerMap::save(ModifiedState save_level)
 		infostream<<"Blocks modified by: "<<std::endl;
 		modprofiler.print(infostream);
 	}
+
+	st.stop();
+
 }
 
 void ServerMap::listAllLoadableBlocks(std::vector<v3s16> &dst)
diff --git a/src/map.h b/src/map.h
index da55fb43..882a3176 100644
--- a/src/map.h
+++ b/src/map.h
@@ -34,6 +34,7 @@ with this program; if not, write to the Free Software Foundation, Inc.,
 #include "nodetimer.h"
 #include "map_settings_manager.h"
 #include "debug.h"
+#include "monitoring.h"
 
 class Settings;
 class MapDatabase;
@@ -310,6 +311,9 @@ class Map /*: public NodeContainer*/
 	u32 m_unprocessed_count = 0;
 	u64 m_inc_trending_up_start_time = 0; // milliseconds
 	bool m_queue_size_timer_started = false;
+
+	Counter* m_map_timer_update_calls_metric;
+	Counter* m_map_timer_update_time_metric;
 };
 
 /*
@@ -448,6 +452,9 @@ class ServerMap : public Map
 	bool m_map_metadata_changed = true;
 	MapDatabase *dbase = nullptr;
 	MapDatabase *dbase_ro = nullptr;
+
+	Counter* m_map_save_calls_metric;
+	Counter* m_map_save_time_metric;
 };
 
 
diff --git a/src/monitoring.cpp b/src/monitoring.cpp
new file mode 100644
index 00000000..6f89c57c
--- /dev/null
+++ b/src/monitoring.cpp
@@ -0,0 +1,188 @@
+/*
+Minetest
+Copyright (C) 2019 BuckarooBanzai/naturefreshmilk, Thomas Rudin <thomas@rudin.io>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#if ENABLE_PROMETHEUS
+//provide prometheus monitoring
+
+#include <prometheus/exposer.h>
+#include <prometheus/registry.h>
+
+#include "monitoring.h"
+#include "settings.h"
+#include "porting.h"
+
+
+//scoped timer
+ScopedTimer::ScopedTimer(Counter* counter){
+	this->counter = counter;
+	this->t_start = porting::getTime(PRECISION_MILLI);
+}
+
+void ScopedTimer::stop(){
+	unsigned long micros = porting::getTime(PRECISION_MILLI) - this->t_start;
+	this->counter->increment(micros);
+}
+
+
+//Prometheus gauge impl
+class PromGauge : public Gauge {
+public:
+  PromGauge(prometheus::Gauge* promg){
+    this->promg = promg;
+  }
+  void increment(const double value){
+    this->promg->Increment(value);
+  }
+  void decrement(const double value){
+    this->promg->Decrement(value);
+  }
+  void set(const double value){
+    this->promg->Set(value);
+  }
+private:
+  prometheus::Gauge* promg;
+};
+
+
+//Prometheus counter impl
+class PromCounter : public Counter {
+public:
+  PromCounter(prometheus::Counter* promc){
+    this->promc = promc;
+  }
+  void increment(const double value){
+    this->promc->Increment(value);
+  }
+private:
+  prometheus::Counter* promc;
+};
+
+//Prometheus histogram impl
+class PromHistogram : public Histogram {
+public:
+  PromHistogram(prometheus::Histogram* promh){
+    this->promh = promh;
+  }
+  void observe(const double value){
+    this->promh->Observe(value);
+  }
+private:
+  prometheus::Histogram* promh;
+};
+
+//Prometheus monitoring impl
+class PrometheusMonitoring : public Monitoring {
+public:
+  PrometheusMonitoring(){}
+
+  void start(){
+    this->exposer = new prometheus::Exposer(g_settings->get("prometheus_bind_address"));
+    this->registry = std::make_shared<prometheus::Registry>();
+
+    this->exposer->RegisterCollectable(this->registry);
+  }
+
+  void stop(){
+    delete this->exposer;
+  }
+
+  Gauge* createGauge(const std::string &name, const std::string &help){
+    prometheus::Gauge& promg = prometheus::BuildGauge()
+      .Name(name)
+      .Help(help)
+      .Register(*(this->registry))
+      .Add({{"component", "main"}});
+
+    return new PromGauge(&promg);
+  }
+
+  Counter* createCounter(const std::string &name, const std::string &help){
+    prometheus::Counter& promc = prometheus::BuildCounter()
+      .Name(name)
+      .Help(help)
+      .Register(*(this->registry))
+      .Add({{"component", "main"}});
+
+    return new PromCounter(&promc);
+  }
+
+  Histogram* createHistogram(const std::string &name, const std::string &help, const std::vector<double> buckets){
+    prometheus::Histogram& promh = prometheus::BuildHistogram()
+      .Name(name)
+      .Help(help)
+      .Register(*(this->registry))
+      .Add({{"component", "main"}}, buckets);
+
+    return new PromHistogram(&promh);
+  }
+
+private:
+  prometheus::Exposer* exposer;
+  std::shared_ptr<prometheus::Registry> registry;
+};
+
+static PrometheusMonitoring prom_monitoring;
+Monitoring* g_monitoring = &prom_monitoring;
+
+
+#else //ENABLE_PROMETHEUS
+//provide no-op impl
+
+//no-op gauge impl
+class NoOpGauge : public Gauge {
+public:
+	inline void increment(const double value){}
+	inline void decrement(const double value){}
+	inline void set(const double value){}
+};
+
+class NoOpScopedTimer : public ScopedTimer {
+public:
+  void stop(){}
+}
+
+//no-op counter impl
+class NoOpCounter : public Counter {
+public:
+  inline void increment(const double value){}
+};
+
+//no-op histogram impl
+class NoOpHistogram : public Histogram {
+public:
+  inline void observe(const double value){}
+};
+
+//no-op monitoring impl
+class NoOpMonitoring : public Monitoring {
+public:
+	void start(){}
+	void stop(){}
+	Gauge* createGauge(const std::string &name, const std::string &help){
+    return new NoOpGauge();
+  }
+  Counter* createCounter(const std::string &name, const std::string &help){
+    return new NoOpCounter();
+  }
+  Histogram* createHistogram(const std::string &name, const std::string &help, const std::vector<double> buckets){
+    return new NoOpHistogram();
+  }
+};
+
+#endif //ENABLE_PROMETHEUS
diff --git a/src/monitoring.h b/src/monitoring.h
new file mode 100644
index 00000000..a10b7ffa
--- /dev/null
+++ b/src/monitoring.h
@@ -0,0 +1,60 @@
+/*
+Minetest
+Copyright (C) 2019 BuckarooBanzai/naturefreshmilk, Thomas Rudin <thomas@rudin.io>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#pragma once
+
+#include <string>
+
+
+class Gauge {
+public:
+	virtual void increment(const double value) = 0;
+	virtual void decrement(const double value) = 0;
+	virtual void set(const double value) = 0;
+};
+
+class Counter {
+public:
+	virtual void increment(const double value) = 0;
+};
+
+class ScopedTimer {
+public:
+	ScopedTimer(Counter* counter);
+	void stop();
+private:
+	Counter* counter;
+	unsigned long t_start;
+};
+
+class Histogram {
+	virtual void observe(const double value) = 0;
+};
+
+class Monitoring {
+public:
+	virtual void start() = 0;
+	virtual void stop() = 0;
+	virtual Gauge* createGauge(const std::string &name, const std::string &help) = 0;
+	virtual Counter* createCounter(const std::string &name, const std::string &help) = 0;
+	virtual Histogram* createHistogram(const std::string &name, const std::string &help, const std::vector<double> buckets) = 0;
+};
+
+// Global object
+extern Monitoring* g_monitoring;
diff --git a/src/network/connection.cpp b/src/network/connection.cpp
index a99e5b14..75af2868 100644
--- a/src/network/connection.cpp
+++ b/src/network/connection.cpp
@@ -28,6 +28,7 @@ with this program; if not, write to the Free Software Foundation, Inc.,
 #include "network/connectionthreads.h"
 #include "network/networkpacket.h"
 #include "network/peerhandler.h"
+#include "network/serveropcodes.h"
 #include "util/serialize.h"
 #include "util/numeric.h"
 #include "util/string.h"
@@ -338,7 +339,7 @@ void ReliablePacketBuffer::insert(BufferedPacket &p, u16 next_expected)
 			fprintf(stderr, "New: seqnum: %05d size: %04u, address: %s\n",
 					readU16(&(p.data[BASE_HEADER_SIZE+1])),p.data.getSize(),
 					p.address.serializeString().c_str());
-			throw IncomingDataCorruption("duplicated packet isn't same as original one");
+			//throw IncomingDataCorruption("duplicated packet isn't same as original one");
 		}
 	}
 	/* insert or push back */
@@ -1161,6 +1162,91 @@ Connection::Connection(u32 protocol_id, u32 max_packet_size, float timeout,
 
 	m_sendThread->start();
 	m_receiveThread->start();
+
+	// to client opcodes
+	for (int i=0; i<TOCLIENT_NUM_MSG_TYPES; i++) {
+		ClientCommandFactory handler = clientCommandFactoryTable[i];
+
+		if (handler.name == std::string("TOCLIENT_NULL")){
+			m_toclient_opcode_metrics[i] = nullptr;
+			continue;
+		}
+
+		std::string name("minetest_engine_connection_");
+		std::string help("Connection send count for ");
+
+		name.append(handler.name);
+		name.append("_count");
+
+		help.append(handler.name);
+		help.append(" packets");
+
+		m_toclient_opcode_metrics[i] = g_monitoring->createCounter(name.c_str(), help.c_str());
+	}
+
+	// to client bytes
+	for (int i=0; i<TOCLIENT_NUM_MSG_TYPES; i++) {
+		ClientCommandFactory handler = clientCommandFactoryTable[i];
+
+		if (handler.name == std::string("TOCLIENT_NULL")){
+			m_toclient_bytes_metrics[i] = nullptr;
+			continue;
+		}
+
+		std::string name("minetest_engine_connection_");
+		std::string help("Connection send bytes for ");
+
+		name.append(handler.name);
+		name.append("_bytes");
+
+		help.append(handler.name);
+		help.append(" bytes");
+
+		m_toclient_bytes_metrics[i] = g_monitoring->createCounter(name.c_str(), help.c_str());
+	}
+
+	// to server opcodes
+	for (int i=0; i<TOSERVER_NUM_MSG_TYPES; i++) {
+		ToServerCommandHandler handler = toServerCommandTable[i];
+
+		if (handler.name == std::string("TOSERVER_NULL")){
+			m_toserver_opcode_metrics[i] = nullptr;
+			continue;
+		}
+
+		std::string name("minetest_engine_connection_");
+		std::string help("Connection recv count for ");
+
+		name.append(handler.name);
+		name.append("_count");
+
+		help.append(handler.name);
+		help.append(" packets");
+
+		m_toserver_opcode_metrics[i] = g_monitoring->createCounter(name.c_str(), help.c_str());
+	}
+
+	// to server bytes
+	for (int i=0; i<TOSERVER_NUM_MSG_TYPES; i++) {
+		ToServerCommandHandler handler = toServerCommandTable[i];
+
+		if (handler.name == std::string("TOSERVER_NULL")){
+			m_toserver_bytes_metrics[i] = nullptr;
+			continue;
+		}
+
+		std::string name("minetest_engine_connection_");
+		std::string help("Connection recv bytes for ");
+
+		name.append(handler.name);
+		name.append("_bytes");
+
+		help.append(handler.name);
+		help.append(" bytes");
+
+		m_toserver_bytes_metrics[i] = g_monitoring->createCounter(name.c_str(), help.c_str());
+	}
+
 }
 
 
@@ -1184,6 +1270,9 @@ Connection::~Connection()
 	for (auto &peer : m_peers) {
 		delete peer.second;
 	}
+
+	//TODO: cleanup clientCommandFactoryTable[i]
+
 }
 
 /* Internal stuff */
@@ -1338,14 +1427,27 @@ bool Connection::Receive(NetworkPacket *pkt, u32 timeout)
 		switch(e.type) {
 		case CONNEVENT_NONE:
 			return false;
-		case CONNEVENT_DATA_RECEIVED:
+		case CONNEVENT_DATA_RECEIVED: {
 			// Data size is lesser than command size, ignoring packet
 			if (e.data.getSize() < 2) {
 				continue;
 			}
 
 			pkt->putRawPacket(*e.data, e.data.getSize(), e.peer_id);
+
+			u16 command = pkt->getCommand();
+			Counter* counter = m_toserver_opcode_metrics[command];
+			if (counter != nullptr) {
+				counter->increment(1);
+			}
+
+			counter = m_toserver_bytes_metrics[command];
+			if (counter != nullptr) {
+				counter->increment(pkt->getSize());
+			}
+
 			return true;
+		}
 		case CONNEVENT_PEER_ADDED: {
 			UDPPeer tmp(e.peer_id, e.address, this);
 			if (m_bc_peerhandler)
@@ -1383,6 +1485,19 @@ void Connection::Send(session_t peer_id, u8 channelnum,
 {
 	assert(channelnum < CHANNEL_COUNT); // Pre-condition
 
+	u16 command = pkt->getCommand();
+	Counter* counter = m_toclient_opcode_metrics[command];
+
+	if (counter != nullptr) {
+		counter->increment(1);
+	}
+
+	counter = m_toclient_bytes_metrics[command];
+
+	if (counter != nullptr) {
+		counter->increment(pkt->getSize());
+	}
+
 	ConnectionCommand c;
 
 	c.send(peer_id, channelnum, pkt, reliable);
diff --git a/src/network/connection.h b/src/network/connection.h
index d7f1e0fe..9f3fa66d 100644
--- a/src/network/connection.h
+++ b/src/network/connection.h
@@ -28,6 +28,7 @@ with this program; if not, write to the Free Software Foundation, Inc.,
 #include "util/thread.h"
 #include "util/numeric.h"
 #include "networkprotocol.h"
+#include "monitoring.h"
 #include <iostream>
 #include <fstream>
 #include <list>
@@ -831,6 +832,11 @@ class Connection
 	bool m_shutting_down = false;
 
 	session_t m_next_remote_peer_id = 2;
+
+	Counter* m_toclient_opcode_metrics[TOCLIENT_NUM_MSG_TYPES];
+	Counter* m_toserver_opcode_metrics[TOSERVER_NUM_MSG_TYPES];
+	Counter* m_toclient_bytes_metrics[TOCLIENT_NUM_MSG_TYPES];
+	Counter* m_toserver_bytes_metrics[TOSERVER_NUM_MSG_TYPES];
 };
 
 } // namespace
diff --git a/src/network/connectionthreads.cpp b/src/network/connectionthreads.cpp
index f8b58c02..de838f50 100644
--- a/src/network/connectionthreads.cpp
+++ b/src/network/connectionthreads.cpp
@@ -73,6 +73,17 @@ ConnectionSendThread::ConnectionSendThread(unsigned int max_packet_size,
 	m_timeout(timeout),
 	m_max_data_packets_per_iteration(g_settings->getU16("max_packets_per_iteration"))
 {
+
+	m_send_bytes_count_metric = g_monitoring->createCounter(
+		"minetest_engine_send_bytes_count",
+		"The udp send bytes count"
+	);
+
+	m_send_packets_count_metric = g_monitoring->createCounter(
+		"minetest_engine_send_packets_count",
+		"The udp send packets count"
+	);
+
 }
 
 void *ConnectionSendThread::run()
@@ -295,6 +306,9 @@ void ConnectionSendThread::runTimeouts(float dtime)
 void ConnectionSendThread::rawSend(const BufferedPacket &packet)
 {
 	try {
+		m_send_bytes_count_metric->increment(packet.data.getSize());
+		m_send_packets_count_metric->increment(1);
+
 		m_connection->m_udpSocket.Send(packet.address, *packet.data,
 			packet.data.getSize());
 		LOG(dout_con << m_connection->getDesc()
@@ -785,6 +799,16 @@ void ConnectionSendThread::sendAsPacket(session_t peer_id, u8 channelnum,
 ConnectionReceiveThread::ConnectionReceiveThread(unsigned int max_packet_size) :
 	Thread("ConnectionReceive")
 {
+	m_receive_bytes_count_metric = g_monitoring->createCounter(
+		"minetest_engine_receive_bytes_count",
+		"The udp receive bytes count"
+	);
+
+	m_receive_packets_count_metric = g_monitoring->createCounter(
+		"minetest_engine_receive_packets_count",
+		"The udp receive packets count"
+	);
+
 }
 
 void *ConnectionReceiveThread::run()
@@ -920,6 +944,9 @@ void ConnectionReceiveThread::receive()
 			s32 received_size = m_connection->m_udpSocket.Receive(sender, *packetdata,
 				packet_maxsize);
 
+			m_receive_bytes_count_metric->increment(received_size);
+			m_receive_packets_count_metric->increment(1);
+
 			if ((received_size < BASE_HEADER_SIZE) ||
 				(readU32(&packetdata[0]) != m_connection->GetProtocolID())) {
 				LOG(derr_con << m_connection->getDesc()
diff --git a/src/network/connectionthreads.h b/src/network/connectionthreads.h
index da4ea92f..8c73bb32 100644
--- a/src/network/connectionthreads.h
+++ b/src/network/connectionthreads.h
@@ -23,6 +23,7 @@ with this program; if not, write to the Free Software Foundation, Inc.,
 #include <cassert>
 #include "threading/thread.h"
 #include "connection.h"
+#include "monitoring.h"
 
 namespace con
 {
@@ -85,6 +86,9 @@ class ConnectionSendThread : public Thread
 	unsigned int m_max_commands_per_iteration = 1;
 	unsigned int m_max_data_packets_per_iteration;
 	unsigned int m_max_packets_requeued = 256;
+
+	Counter* m_send_bytes_count_metric;
+	Counter* m_send_packets_count_metric;
 };
 
 class ConnectionReceiveThread : public Thread
@@ -146,5 +150,8 @@ class ConnectionReceiveThread : public Thread
 	static const PacketTypeHandler packetTypeRouter[PACKET_TYPE_MAX];
 
 	Connection *m_connection = nullptr;
+
+	Counter* m_receive_bytes_count_metric;
+	Counter* m_receive_packets_count_metric;
 };
 }
diff --git a/src/server.cpp b/src/server.cpp
index f1613cff..ed770ffa 100644
--- a/src/server.cpp
+++ b/src/server.cpp
@@ -104,6 +104,8 @@ void *ServerThread::run()
 
 	m_server->AsyncRunStep(true);
 
+	u16 receive_iterations = g_settings->getU16("receive_iterations_per_step");
+
 	while (!stopRequested()) {
 		try {
 			m_server->AsyncRunStep();
@@ -416,6 +418,134 @@ void Server::init()
 	m_max_chatmessage_length = g_settings->getU16("chat_message_max_size");
 	m_csm_restriction_flags = g_settings->getU64("csm_restriction_flags");
 	m_csm_restriction_noderange = g_settings->getU32("csm_restriction_noderange");
+
+	// Register metrics
+	m_tick_count_metric = g_monitoring->createCounter(
+		"minetest_engine_tick_count",
+		"The server tick count"
+	);
+
+	m_async_run_count_metric = g_monitoring->createCounter(
+		"minetest_engine_async_run_count",
+		"The async step run count"
+	);
+
+	m_async_run_time_metric = g_monitoring->createCounter(
+		"minetest_engine_async_run_time",
+		"The async step run time"
+	);
+
+	m_receive_packets_count_metric = g_monitoring->createCounter(
+		"minetest_engine_receive_packets_run_count",
+		"The receive packets run count"
+	);
+
+	m_receive_packets_time_metric = g_monitoring->createCounter(
+		"minetest_engine_receive_packets_time",
+		"The receive packets run time"
+	);
+
+	m_sendblocks_count_metric = g_monitoring->createCounter(
+		"minetest_engine_sendblocks_count",
+		"The sendblocks count"
+	);
+
+	m_sendblocks_time_metric = g_monitoring->createCounter(
+		"minetest_engine_sendblocks_time",
+		"The sendblocks run time"
+	);
+
+	m_sendblock_no_lock_count_metric = g_monitoring->createCounter(
+		"minetest_engine_sendblock_no_lock_count",
+		"The sendblock no lock count"
+	);
+
+	m_sendblock_no_lock_time_metric = g_monitoring->createCounter(
+		"minetest_engine_sendblock_no_lock_time",
+		"The sendblock no lock run time"
+	);
+
+	m_sentblocks_count_metric = g_monitoring->createCounter(
+		"minetest_engine_sent_blocks",
+		"sent blocks counter"
+	);
+
+	m_sentblocks_unsent_count_metric = g_monitoring->createCounter(
+		"minetest_engine_unsent_blocks",
+		"unsent blocks counter"
+	);
+
+	m_mapevents_count_metric = g_monitoring->createCounter(
+		"minetest_engine_mapevents_count",
+		"The mapevents run count"
+	);
+
+	m_mapevents_time_metric = g_monitoring->createCounter(
+		"minetest_engine_mapevents_time",
+		"The mapevents run time"
+	);
+
+	m_unsent_mapevents_count_metric = g_monitoring->createCounter(
+		"minetest_engine_unsent_mapevents_count",
+		"The unsent mapevents count"
+	);
+
+
+	m_liquid_transform_time_metric = g_monitoring->createCounter(
+		"minetest_engine_liquid_transform_time",
+		"The liquid transform time"
+	);
+
+	m_client_interface_step_time_metric = g_monitoring->createCounter(
+		"minetest_engine_client_interface_step_time",
+		"The client interface step time"
+	);
+
+	m_send_announce_time_metric = g_monitoring->createCounter(
+		"minetest_engine_send_announce_time",
+		"The send announce time"
+	);
+
+	m_active_objects_time_metric = g_monitoring->createCounter(
+		"minetest_engine_active_objects_time",
+		"The active objects time"
+	);
+
+	m_send_objects_messages_time_metric = g_monitoring->createCounter(
+		"minetest_engine_send_objects_messages_time",
+		"The send object messages time"
+	);
+
+	m_save_map_players_time_metric = g_monitoring->createCounter(
+		"minetest_engine_save_map_players_time",
+		"The save map players time"
+	);
+
+	m_max_lag_gauge_metric = g_monitoring->createGauge(
+		"minetest_engine_max_lag",
+		"reported max lag"
+	);
+
+	m_dtime_count_metric = g_monitoring->createCounter(
+		"minetest_engine_dtime_count",
+		"cumulative dtime count"
+	);
+
+	m_forceload_block_count_metric = g_monitoring->createGauge(
+		"minetest_engine_forceloaded_blocks",
+		"number of forceloaded blocks"
+	);
+
+	m_handlecommand_count_metric = g_monitoring->createCounter(
+		"minetest_engine_handlecommand_count",
+		"The handlecommand run count"
+	);
+
+	m_handlecommand_time_metric = g_monitoring->createCounter(
+		"minetest_engine_handlecommand_time",
+		"The handlecommand run time"
+	);
+
 }
 
 void Server::start()
@@ -462,6 +592,8 @@ void Server::stop()
 
 void Server::step(float dtime)
 {
+	m_tick_count_metric->increment(1);
+
 	// Limit a bit
 	if (dtime > 2.0)
 		dtime = 2.0;
@@ -479,10 +611,15 @@ void Server::step(float dtime)
 		}
 		throw ServerError("AsyncErr: " + async_err);
 	}
+
 }
 
 void Server::AsyncRunStep(bool initial_step)
 {
+	g_profiler->add("Server::AsyncRunStep (num)", 1);
+	m_async_run_count_metric->increment(1);
+	ScopedTimer st(m_async_run_time_metric);
+
 
 	float dtime;
 	{
@@ -490,13 +627,17 @@ void Server::AsyncRunStep(bool initial_step)
 		dtime = m_step_dtime;
 	}
 
+	m_dtime_count_metric->increment(dtime);
+
 	{
 		// Send blocks to clients
 		SendBlocks(dtime);
 	}
 
-	if((dtime < 0.001) && !initial_step)
+	if((dtime < 0.001) && !initial_step){
+		st.stop();
 		return;
+	}
 
 	ScopeProfiler sp(g_profiler, "Server::AsyncRunStep()", SPT_AVG);
 
@@ -519,6 +660,9 @@ void Server::AsyncRunStep(bool initial_step)
 	*/
 	m_env->setTimeOfDaySpeed(g_settings->getFloat("time_speed"));
 
+	//Update number of forceloaded blocks
+	m_forceload_block_count_metric->set( m_env->getForceloadedBlocks()->size() );
+
 	/*
 		Send to clients at constant intervals
 	*/
@@ -543,6 +687,8 @@ void Server::AsyncRunStep(bool initial_step)
 			max_lag = dtime;
 		}
 		m_env->reportMaxLagEstimate(max_lag);
+		m_max_lag_gauge_metric->set(max_lag);
+
 		// Step environment
 		m_env->step(dtime);
 	}
@@ -582,6 +728,8 @@ void Server::AsyncRunStep(bool initial_step)
 	m_liquid_transform_timer += dtime;
 	if(m_liquid_transform_timer >= m_liquid_transform_every)
 	{
+		ScopedTimer st2(m_liquid_transform_time_metric);
+
 		m_liquid_transform_timer -= m_liquid_transform_every;
 
 		MutexAutoLock lock(m_env_mutex);
@@ -597,13 +745,21 @@ void Server::AsyncRunStep(bool initial_step)
 		if (!modified_blocks.empty()) {
 			SetBlocksNotSent(modified_blocks);
 		}
+
+		st.stop();
+	}
+
+	{
+		ScopedTimer st2(m_client_interface_step_time_metric);
+		m_clients.step(dtime);
+		st2.stop();
 	}
-	m_clients.step(dtime);
 
 	m_lag += (m_lag > dtime ? -1 : 1) * dtime/100;
 #if USE_CURL
 	// send masterserver announce
 	{
+		ScopedTimer st2(m_send_announce_time_metric);
 		float &counter = m_masterserver_timer;
 		if (!isSingleplayer() && (!counter || counter >= 300.0) &&
 				g_settings->getBool("server_announce")) {
@@ -621,6 +777,7 @@ void Server::AsyncRunStep(bool initial_step)
 			counter = 0.01;
 		}
 		counter += dtime;
+		st2.stop();
 	}
 #endif
 
@@ -628,6 +785,8 @@ void Server::AsyncRunStep(bool initial_step)
 		Check added and deleted active objects
 	*/
 	{
+		ScopedTimer st2(m_active_objects_time_metric);
+
 		//infostream<<"Server: Checking added and deleted active objects"<<std::endl;
 		MutexAutoLock envlock(m_env_mutex);
 
@@ -665,6 +824,8 @@ void Server::AsyncRunStep(bool initial_step)
 				}
 			}
 		}
+
+		st2.stop();
 	}
 
 	/*
@@ -672,7 +833,8 @@ void Server::AsyncRunStep(bool initial_step)
 	*/
 	{
 		MutexAutoLock envlock(m_env_mutex);
-		ScopeProfiler sp(g_profiler, "Server: send SAO messages");
+		ScopeProfiler sp(g_profiler, "Server: sending object messages");
+		ScopedTimer st2(m_send_objects_messages_time_metric);
 
 		// Key = object id
 		// Value = data sent by object
@@ -762,12 +924,17 @@ void Server::AsyncRunStep(bool initial_step)
 		for (auto &buffered_message : buffered_messages) {
 			delete buffered_message.second;
 		}
+
+		st2.stop();
 	}
 
 	/*
 		Send queued-for-sending map edit events.
 	*/
 	{
+		m_mapevents_count_metric->increment(1);
+		ScopedTimer st2(m_mapevents_time_metric);
+
 		// We will be accessing the environment
 		MutexAutoLock lock(m_env_mutex);
 
@@ -780,6 +947,7 @@ void Server::AsyncRunStep(bool initial_step)
 			disable_single_change_sending = true;
 
 		int event_count = m_unsent_map_edit_queue.size();
+		m_unsent_mapevents_count_metric->increment(event_count);
 
 		// We'll log the amount of each
 		Profiler prof;
@@ -870,6 +1038,8 @@ void Server::AsyncRunStep(bool initial_step)
 		// Send all metadata updates
 		if (node_meta_updates.size())
 			sendMetadataChanged(node_meta_updates);
+
+		st2.stop();
 	}
 
 	/*
@@ -888,6 +1058,8 @@ void Server::AsyncRunStep(bool initial_step)
 
 	// Save map, players and auth stuff
 	{
+		ScopedTimer st2(m_save_map_players_time_metric);
+
 		float &counter = m_savemap_timer;
 		counter += dtime;
 		static thread_local const float save_interval =
@@ -912,13 +1084,19 @@ void Server::AsyncRunStep(bool initial_step)
 			// Save environment metadata
 			m_env->saveMeta();
 		}
+
+		st2.stop();
 	}
 
 	m_shutdown_state.tick(dtime, this);
+	st.stop();
+
 }
 
 void Server::Receive()
 {
+	m_receive_packets_count_metric->increment(1);
+
 	NetworkPacket pkt;
 	session_t peer_id;
 	bool first = true;
@@ -930,6 +1108,7 @@ void Server::Receive()
 				In the first iteration *wait* for a packet, afterwards process
 				all packets that are immediately available (no waiting).
 			*/
+			ScopedTimer st(m_receive_packets_time_metric);
 			if (first) {
 				m_con->Receive(&pkt);
 				first = false;
@@ -940,6 +1119,7 @@ void Server::Receive()
 
 			peer_id = pkt.getPeerId();
 			ProcessData(&pkt);
+			st.stop();
 		} catch (const con::InvalidIncomingDataException &e) {
 			infostream << "Server::Receive(): InvalidIncomingDataException: what()="
 					<< e.what() << std::endl;
@@ -1040,8 +1220,14 @@ PlayerSAO* Server::StageTwoClientInit(session_t peer_id)
 
 inline void Server::handleCommand(NetworkPacket *pkt)
 {
+	m_handlecommand_count_metric->increment(1);
+	ScopedTimer st(m_handlecommand_time_metric);
+
 	const ToServerCommandHandler &opHandle = toServerCommandTable[pkt->getCommand()];
+
 	(this->*opHandle.handler)(pkt);
+
+	st.stop();
 }
 
 void Server::ProcessData(NetworkPacket *pkt)
@@ -2307,6 +2493,10 @@ void Server::SendBlockNoLock(session_t peer_id, MapBlock *block, u8 ver,
 		Create a packet with the block in the right format
 	*/
 
+	m_sendblock_no_lock_count_metric->increment(1);
+	ScopedTimer st(m_sendblock_no_lock_time_metric);
+
+
 	std::ostringstream os(std::ios_base::binary);
 	block->serialize(os, ver, false);
 	block->serializeNetworkSpecific(os);
@@ -2317,10 +2507,15 @@ void Server::SendBlockNoLock(session_t peer_id, MapBlock *block, u8 ver,
 	pkt << block->getPos();
 	pkt.putRawString(s.c_str(), s.size());
 	Send(&pkt);
+
+	st.stop();
 }
 
 void Server::SendBlocks(float dtime)
 {
+	m_sendblocks_count_metric->increment(1);
+	ScopedTimer st(m_sendblocks_time_metric);
+
 	MutexAutoLock envlock(m_env_mutex);
 	//TODO check if one big lock could be faster then multiple small ones
 
@@ -2346,6 +2541,8 @@ void Server::SendBlocks(float dtime)
 		m_clients.unlock();
 	}
 
+	m_sentblocks_count_metric->increment(queue.size());
+
 	// Sort.
 	// Lowest priority number comes first.
 	// Lowest is most important.
@@ -2362,8 +2559,10 @@ void Server::SendBlocks(float dtime)
 	Map &map = m_env->getMap();
 
 	for (const PrioritySortedBlockTransfer &block_to_send : queue) {
-		if (total_sending >= max_blocks_to_send)
+		if (total_sending >= max_blocks_to_send){
+			m_sentblocks_unsent_count_metric->increment(queue.size() - total_sending);
 			break;
+		}
 
 		MapBlock *block = map.getBlockNoCreateNoEx(block_to_send.pos);
 		if (!block)
@@ -2381,6 +2580,8 @@ void Server::SendBlocks(float dtime)
 		total_sending++;
 	}
 	m_clients.unlock();
+
+	st.stop();
 }
 
 bool Server::SendBlock(session_t peer_id, const v3s16 &blockpos)
@@ -3093,9 +3294,16 @@ std::wstring Server::getStatusString()
 
 			// Get name of player
 			std::wstring name = L"unknown";
-			if (player)
+			if (player){
 				name = narrow_to_wide(player->getName());
 
+				std::set<std::string> privs_s = getPlayerEffectivePrivs(player->getName());
+				const bool is_hidden = privs_s.find("status_hide") != privs_s.end();
+
+				if (is_hidden)
+					continue;
+			}
+
 			// Add name to information string
 			if (!first)
 				os << L", ";
diff --git a/src/server.h b/src/server.h
index 28d9c8fa..9942da95 100644
--- a/src/server.h
+++ b/src/server.h
@@ -36,6 +36,7 @@ with this program; if not, write to the Free Software Foundation, Inc.,
 #include "serverenvironment.h"
 #include "clientiface.h"
 #include "chatmessage.h"
+#include "monitoring.h"
 #include <string>
 #include <list>
 #include <map>
@@ -668,6 +669,47 @@ class Server : public con::PeerHandler, public MapEventReceiver,
 
 	// ModChannel manager
 	std::unique_ptr<ModChannelMgr> m_modchannel_mgr;
+
+	/*
+	Metrics
+	*/
+	Counter* m_tick_count_metric;
+
+	Counter* m_async_run_count_metric;
+	Counter* m_async_run_time_metric;
+
+	Counter* m_dtime_count_metric;
+
+	Counter* m_receive_packets_count_metric;
+	Counter* m_receive_packets_time_metric;
+
+	Counter* m_sentblocks_count_metric;
+	Counter* m_sentblocks_unsent_count_metric;
+
+	Counter* m_sendblocks_count_metric;
+	Counter* m_sendblocks_time_metric;
+
+	Counter* m_sendblock_no_lock_count_metric;
+	Counter* m_sendblock_no_lock_time_metric;
+
+	Counter* m_mapevents_count_metric;
+	Counter* m_mapevents_time_metric;
+
+	Counter* m_unsent_mapevents_count_metric;
+
+	Counter* m_liquid_transform_time_metric;
+	Counter* m_client_interface_step_time_metric;
+	Counter* m_send_announce_time_metric;
+	Counter* m_active_objects_time_metric;
+	Counter* m_send_objects_messages_time_metric;
+	Counter* m_save_map_players_time_metric;
+
+	Gauge* m_max_lag_gauge_metric;
+	Gauge* m_forceload_block_count_metric;
+
+	Counter* m_handlecommand_count_metric;
+	Counter* m_handlecommand_time_metric;
+
 };
 
 /*
diff --git a/src/serverenvironment.cpp b/src/serverenvironment.cpp
index 333d32ff..eb259904 100644
--- a/src/serverenvironment.cpp
+++ b/src/serverenvironment.cpp
@@ -397,6 +397,18 @@ ServerEnvironment::ServerEnvironment(ServerMap *map,
 	m_path_world(path_world),
 	m_rgen(seed())
 {
+
+
+	m_step_count_metric = g_monitoring->createCounter(
+		"minetest_engine_environmentstep_count",
+		"The environmentstep run count"
+	);
+
+	m_step_time_metric = g_monitoring->createCounter(
+		"minetest_engine_environmentstep_time",
+		"The environmentstep run time"
+	);
+
 	// Determine which database backend to use
 	std::string conf_path = path_world + DIR_DELIM + "world.mt";
 	Settings conf;
@@ -1200,6 +1212,9 @@ void ServerEnvironment::clearObjects(ClearObjectsMode mode)
 
 void ServerEnvironment::step(float dtime)
 {
+	m_step_count_metric->increment(1);
+	ScopedTimer st(m_step_time_metric);
+
 	ScopeProfiler sp2(g_profiler, "ServerEnv::step()", SPT_AVG);
 	/* Step time of day */
 	stepTimeOfDay(dtime);
@@ -1467,6 +1482,8 @@ void ServerEnvironment::step(float dtime)
 
 	// Send outdated detached inventories
 	m_server->sendDetachedInventories(PEER_ID_INEXISTENT, true);
+
+	st.stop();
 }
 
 u32 ServerEnvironment::addParticleSpawner(float exptime)
diff --git a/src/serverenvironment.h b/src/serverenvironment.h
index cc4ecd79..4ae0b4a2 100644
--- a/src/serverenvironment.h
+++ b/src/serverenvironment.h
@@ -23,6 +23,7 @@ with this program; if not, write to the Free Software Foundation, Inc.,
 #include "environment.h"
 #include "mapnode.h"
 #include "settings.h"
+#include "monitoring.h"
 #include "server/activeobjectmgr.h"
 #include "util/numeric.h"
 #include <set>
@@ -477,4 +478,8 @@ class ServerEnvironment : public Environment
 	IntervalLimiter m_particle_management_interval;
 	std::unordered_map<u32, float> m_particle_spawners;
 	std::unordered_map<u32, u16> m_particle_spawner_attachments;
+
+	// monitoring
+	Counter* m_step_count_metric;
+	Counter* m_step_time_metric;
 };
